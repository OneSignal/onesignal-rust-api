/*
 * OneSignal
 *
 * A powerful way to send personalized messages at scale and build effective customer engagement strategies. Learn more at onesignal.com
 *
 * The version of the OpenAPI document: 5.2.0
 * Contact: devrel@onesignal.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`cancel_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelNotificationError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_alias`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAliasError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericError),
    Status409(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_alias_by_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAliasBySubscriptionError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericError),
    Status409(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAppError {
    Status400(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNotificationError {
    Status400(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_segment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSegmentError {
    Status400(crate::models::GenericError),
    Status409(crate::models::CreateSegmentConflictResponse),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSubscriptionError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericError),
    Status409(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserError {
    Status400(crate::models::GenericError),
    Status409(crate::models::CreateUserConflictResponse),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_alias`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAliasError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericError),
    Status409(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_segment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSegmentError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericSuccessBoolResponse),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSubscriptionError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericError),
    Status409(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserError {
    Status400(crate::models::GenericError),
    Status409(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportEventsError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export_subscriptions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportSubscriptionsError {
    Status400(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_aliases`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAliasesError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_aliases_by_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAliasesBySubscriptionError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAppError {
    Status400(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_apps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAppsError {
    Status400(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNotificationError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_notification_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNotificationHistoryError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_notifications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNotificationsError {
    Status400(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_outcomes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOutcomesError {
    Status400(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_segments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSegmentsError {
    Status400(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`transfer_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransferSubscriptionError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericError),
    Status409(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unsubscribe_email_with_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnsubscribeEmailWithTokenError {
    Status400(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAppError {
    Status400(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_live_activity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateLiveActivityError {
    Status400(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSubscriptionError {
    Status400(crate::models::GenericError),
    Status404(crate::models::GenericError),
    Status409(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserError {
    Status400(crate::models::GenericError),
    Status409(crate::models::GenericError),
    Status429(crate::models::RateLimitError),
    UnknownValue(serde_json::Value),
}


/// Used to stop a scheduled or currently outgoing notification
pub async fn cancel_notification(configuration: &configuration::Configuration, app_id: &str, notification_id: &str) -> Result<crate::models::GenericSuccessBoolResponse, Error<CancelNotificationError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/notifications/{notification_id}", configuration.base_path, notification_id=crate::apis::urlencode(notification_id));
    let mut req_builder = client.request(reqwest::Method::DELETE, uri_str.as_str());

    req_builder = req_builder.query(&[("app_id", &app_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<CancelNotificationError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Upserts one or more Aliases to an existing User identified by (:alias_label, :alias_id).
pub async fn create_alias(configuration: &configuration::Configuration, app_id: &str, alias_label: &str, alias_id: &str, user_identity_body: crate::models::UserIdentityBody) -> Result<crate::models::UserIdentityBody, Error<CreateAliasError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/users/by/{alias_label}/{alias_id}/identity", configuration.base_path, app_id=crate::apis::urlencode(app_id), alias_label=crate::apis::urlencode(alias_label), alias_id=crate::apis::urlencode(alias_id));
    let mut req_builder = client.request(reqwest::Method::PATCH, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }
    req_builder = req_builder.json(&user_identity_body);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<CreateAliasError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Upserts one or more Aliases for the User identified by :subscription_id.
pub async fn create_alias_by_subscription(configuration: &configuration::Configuration, app_id: &str, subscription_id: &str, user_identity_body: crate::models::UserIdentityBody) -> Result<crate::models::UserIdentityBody, Error<CreateAliasBySubscriptionError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/subscriptions/{subscription_id}/user/identity", configuration.base_path, app_id=crate::apis::urlencode(app_id), subscription_id=crate::apis::urlencode(subscription_id));
    let mut req_builder = client.request(reqwest::Method::PATCH, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }
    req_builder = req_builder.json(&user_identity_body);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<CreateAliasBySubscriptionError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Creates a new OneSignal app
pub async fn create_app(configuration: &configuration::Configuration, app: crate::models::App) -> Result<crate::models::App, Error<CreateAppError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps", configuration.base_path);
    let mut req_builder = client.request(reqwest::Method::POST, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.organization_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }
    req_builder = req_builder.json(&app);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<CreateAppError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Sends notifications to your users 
pub async fn create_notification(configuration: &configuration::Configuration, notification: crate::models::Notification) -> Result<crate::models::CreateNotificationSuccessResponse, Error<CreateNotificationError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/notifications", configuration.base_path);
    let mut req_builder = client.request(reqwest::Method::POST, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }
    req_builder = req_builder.json(&notification);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<CreateNotificationError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Create a segment visible and usable in the dashboard and API - Required: OneSignal Paid Plan The Create Segment method is used when you want your server to programmatically create a segment instead of using the OneSignal Dashboard UI. Just like creating Segments from the dashboard you can pass in filters with multiple \"AND\" or \"OR\" operator's. &#x1F6A7; Does Not Update Segments This endpoint will only create segments, it does not edit or update currently created Segments. You will need to use the Delete Segment endpoint and re-create it with this endpoint to edit. 
pub async fn create_segment(configuration: &configuration::Configuration, app_id: &str, segment: Option<crate::models::Segment>) -> Result<crate::models::CreateSegmentSuccessResponse, Error<CreateSegmentError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/segments", configuration.base_path, app_id=crate::apis::urlencode(app_id));
    let mut req_builder = client.request(reqwest::Method::POST, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }
    req_builder = req_builder.json(&segment);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<CreateSegmentError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Creates a new Subscription under the User provided. Useful to add email addresses and SMS numbers to the User.
pub async fn create_subscription(configuration: &configuration::Configuration, app_id: &str, alias_label: &str, alias_id: &str, subscription_body: crate::models::SubscriptionBody) -> Result<crate::models::SubscriptionBody, Error<CreateSubscriptionError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/users/by/{alias_label}/{alias_id}/subscriptions", configuration.base_path, app_id=crate::apis::urlencode(app_id), alias_label=crate::apis::urlencode(alias_label), alias_id=crate::apis::urlencode(alias_id));
    let mut req_builder = client.request(reqwest::Method::POST, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }
    req_builder = req_builder.json(&subscription_body);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<CreateSubscriptionError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Creates a User, optionally Subscriptions owned by the User as well as Aliases. Aliases provided in the payload will be used to look up an existing User.
pub async fn create_user(configuration: &configuration::Configuration, app_id: &str, user: crate::models::User) -> Result<crate::models::User, Error<CreateUserError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/users", configuration.base_path, app_id=crate::apis::urlencode(app_id));
    let mut req_builder = client.request(reqwest::Method::POST, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }
    req_builder = req_builder.json(&user);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<CreateUserError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Deletes an alias by alias label
pub async fn delete_alias(configuration: &configuration::Configuration, app_id: &str, alias_label: &str, alias_id: &str, alias_label_to_delete: &str) -> Result<crate::models::UserIdentityBody, Error<DeleteAliasError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/users/by/{alias_label}/{alias_id}/identity/{alias_label_to_delete}", configuration.base_path, app_id=crate::apis::urlencode(app_id), alias_label=crate::apis::urlencode(alias_label), alias_id=crate::apis::urlencode(alias_id), alias_label_to_delete=crate::apis::urlencode(alias_label_to_delete));
    let mut req_builder = client.request(reqwest::Method::DELETE, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<DeleteAliasError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Delete a segment (not user devices) - Required: OneSignal Paid Plan You can delete a segment under your app by calling this API. You must provide an API key in the Authorization header that has admin access on the app. The segment_id can be found in the URL of the segment when viewing it in the dashboard. 
pub async fn delete_segment(configuration: &configuration::Configuration, app_id: &str, segment_id: &str) -> Result<crate::models::GenericSuccessBoolResponse, Error<DeleteSegmentError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/segments/{segment_id}", configuration.base_path, app_id=crate::apis::urlencode(app_id), segment_id=crate::apis::urlencode(segment_id));
    let mut req_builder = client.request(reqwest::Method::DELETE, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<DeleteSegmentError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Deletes the Subscription.
pub async fn delete_subscription(configuration: &configuration::Configuration, app_id: &str, subscription_id: &str) -> Result<(), Error<DeleteSubscriptionError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/subscriptions/{subscription_id}", configuration.base_path, app_id=crate::apis::urlencode(app_id), subscription_id=crate::apis::urlencode(subscription_id));
    let mut req_builder = client.request(reqwest::Method::DELETE, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let entity: Option<DeleteSubscriptionError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Removes the User identified by (:alias_label, :alias_id), and all Subscriptions and Aliases
pub async fn delete_user(configuration: &configuration::Configuration, app_id: &str, alias_label: &str, alias_id: &str) -> Result<(), Error<DeleteUserError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/users/by/{alias_label}/{alias_id}", configuration.base_path, app_id=crate::apis::urlencode(app_id), alias_label=crate::apis::urlencode(alias_label), alias_id=crate::apis::urlencode(alias_id));
    let mut req_builder = client.request(reqwest::Method::DELETE, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let entity: Option<DeleteUserError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Generate a compressed CSV report of all of the events data for a notification. This will return a URL immediately upon success but it may take several minutes for the CSV to become available at that URL depending on the volume of data. Only one export can be in-progress per OneSignal account at any given time.
pub async fn export_events(configuration: &configuration::Configuration, notification_id: &str, app_id: &str) -> Result<crate::models::ExportEventsSuccessResponse, Error<ExportEventsError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/notifications/{notification_id}/export_events?app_id={app_id}", configuration.base_path, notification_id=crate::apis::urlencode(notification_id));
    let mut req_builder = client.request(reqwest::Method::POST, uri_str.as_str());

    req_builder = req_builder.query(&[("app_id", &app_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<ExportEventsError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Generate a compressed CSV export of all of your current user data This method can be used to generate a compressed CSV export of all of your current user data. It is a much faster alternative than retrieving this data using the /players API endpoint. The file will be compressed using GZip. The file may take several minutes to generate depending on the number of users in your app. The URL generated will be available for 3 days and includes random v4 uuid as part of the resource name to be unguessable. &#x1F6A7; 403 Error Responses          You can test if it is complete by making a GET request to the csv_file_url value. This file may take time to generate depending on how many device records are being pulled. If the file is not ready, a 403 error will be returned. Otherwise the file itself will be returned. &#x1F6A7; Requires Authentication Key Requires your OneSignal App's REST API Key, available in Keys & IDs. &#x1F6A7; Concurrent Exports Only one concurrent export is allowed per OneSignal account. Please ensure you have successfully downloaded the .csv.gz file before exporting another app. CSV File Format: - Default Columns:   | Field | Details |   | --- | --- |   | id | OneSignal Player Id |   | identifier | Push Token |   | session_count | Number of times they visited the app or site   | language | Device language code |   | timezone | Number of seconds away from UTC. Example: -28800 |   | game_version | Version of your mobile app gathered from Android Studio versionCode in your App/build.gradle and iOS uses kCFBundleVersionKey in Xcode. |   | device_os | Device Operating System Version. Example: 80 = Chrome 80, 9 = Android 9 |   | device_type | Device Operating System Type |   | device_model | Device Hardware String Code. Example: Mobile Web Subscribers will have `Linux armv` |   | ad_id | Based on the Google Advertising Id for Android, identifierForVendor for iOS. OptedOut means user turned off Advertising tracking on the device. |   | tags | Current OneSignal Data Tags on the device. |   | last_active | Date and time the user last opened the mobile app or visited the site. |   | playtime | Total amount of time in seconds the user had the mobile app open. |   | amount_spent |  Mobile only - amount spent in USD on In-App Purchases. |    | created_at | Date and time the device record was created in OneSignal. Mobile - first time they opened the app with OneSignal SDK. Web - first time the user subscribed to the site. |   | invalid_identifier | t = unsubscribed, f = subscibed |   | badge_count | Current number of badges on the device | - Extra Columns:   | Field | Details |   | --- | --- |   | external_user_id | Your User Id set on the device |   | notification_types | Notification types |   | location | Location points (Latitude and Longitude) set on the device. |   | country | Country code |   | rooted | Android device rooted or not |   | ip | IP Address of the device if being tracked. See Handling Personal Data. |   | web_auth | Web Only authorization key. |   | web_p256 | Web Only p256 key. | 
pub async fn export_subscriptions(configuration: &configuration::Configuration, app_id: &str, export_subscriptions_request_body: Option<crate::models::ExportSubscriptionsRequestBody>) -> Result<crate::models::ExportSubscriptionsSuccessResponse, Error<ExportSubscriptionsError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/players/csv_export?app_id={app_id}", configuration.base_path, app_id=crate::apis::urlencode(app_id));
    let mut req_builder = client.request(reqwest::Method::POST, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }
    req_builder = req_builder.json(&export_subscriptions_request_body);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<ExportSubscriptionsError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Lists all Aliases for the User identified by (:alias_label, :alias_id).
pub async fn get_aliases(configuration: &configuration::Configuration, app_id: &str, alias_label: &str, alias_id: &str) -> Result<crate::models::UserIdentityBody, Error<GetAliasesError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/users/by/{alias_label}/{alias_id}/identity", configuration.base_path, app_id=crate::apis::urlencode(app_id), alias_label=crate::apis::urlencode(alias_label), alias_id=crate::apis::urlencode(alias_id));
    let mut req_builder = client.request(reqwest::Method::GET, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<GetAliasesError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Lists all Aliases for the User identified by :subscription_id.
pub async fn get_aliases_by_subscription(configuration: &configuration::Configuration, app_id: &str, subscription_id: &str) -> Result<crate::models::UserIdentityBody, Error<GetAliasesBySubscriptionError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/subscriptions/{subscription_id}/user/identity", configuration.base_path, app_id=crate::apis::urlencode(app_id), subscription_id=crate::apis::urlencode(subscription_id));
    let mut req_builder = client.request(reqwest::Method::GET, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<GetAliasesBySubscriptionError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// View the details of a single OneSignal app
pub async fn get_app(configuration: &configuration::Configuration, app_id: &str) -> Result<crate::models::App, Error<GetAppError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}", configuration.base_path, app_id=crate::apis::urlencode(app_id));
    let mut req_builder = client.request(reqwest::Method::GET, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.organization_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<GetAppError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// View the details of all of your current OneSignal apps
pub async fn get_apps(configuration: &configuration::Configuration, ) -> Result<Vec<crate::models::App>, Error<GetAppsError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps", configuration.base_path);
    let mut req_builder = client.request(reqwest::Method::GET, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.organization_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<GetAppsError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// View the details of a single notification and outcomes associated with it
pub async fn get_notification(configuration: &configuration::Configuration, app_id: &str, notification_id: &str) -> Result<crate::models::NotificationWithMeta, Error<GetNotificationError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/notifications/{notification_id}", configuration.base_path, notification_id=crate::apis::urlencode(notification_id));
    let mut req_builder = client.request(reqwest::Method::GET, uri_str.as_str());

    req_builder = req_builder.query(&[("app_id", &app_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<GetNotificationError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// -> View the devices sent a message - OneSignal Paid Plan Required This method will return all devices that were sent the given notification_id of an Email or Push Notification if used within 7 days of the date sent. After 7 days of the sending date, the message history data will be unavailable. After a successful response is received, the destination url may be polled until the file becomes available. Most exports are done in ~1-3 minutes, so setting a poll interval of 10 seconds should be adequate. For use cases that are not meant to be consumed by a script, an email will be sent to the supplied email address. &#x1F6A7; Requirements A OneSignal Paid Plan. Turn on Send History via OneSignal API in Settings -> Analytics. Cannot get data before this was turned on. Must be called within 7 days after sending the message. Messages targeting under 1000 recipients will not have \"sent\" events recorded, but will show \"clicked\" events. Requires your OneSignal App's REST API Key, available in Keys & IDs.
pub async fn get_notification_history(configuration: &configuration::Configuration, notification_id: &str, get_notification_history_request_body: crate::models::GetNotificationHistoryRequestBody) -> Result<crate::models::NotificationHistorySuccessResponse, Error<GetNotificationHistoryError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/notifications/{notification_id}/history", configuration.base_path, notification_id=crate::apis::urlencode(notification_id));
    let mut req_builder = client.request(reqwest::Method::POST, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }
    req_builder = req_builder.json(&get_notification_history_request_body);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<GetNotificationHistoryError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// View the details of multiple notifications
pub async fn get_notifications(configuration: &configuration::Configuration, app_id: &str, limit: Option<i32>, offset: Option<i32>, kind: Option<i32>) -> Result<crate::models::NotificationSlice, Error<GetNotificationsError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/notifications", configuration.base_path);
    let mut req_builder = client.request(reqwest::Method::GET, uri_str.as_str());

    req_builder = req_builder.query(&[("app_id", &app_id.to_string())]);
    if let Some(ref str) = limit {
        req_builder = req_builder.query(&[("limit", &str.to_string())]);
    }
    if let Some(ref str) = offset {
        req_builder = req_builder.query(&[("offset", &str.to_string())]);
    }
    if let Some(ref str) = kind {
        req_builder = req_builder.query(&[("kind", &str.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<GetNotificationsError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// View the details of all the outcomes associated with your app  &#x1F6A7; Requires Authentication Key Requires your OneSignal App's REST API Key, available in Keys & IDs.  &#x1F6A7; Outcome Data Limitations Outcomes are only accessible for around 30 days before deleted from our servers. You will need to export this data every month if you want to keep it. 
pub async fn get_outcomes(configuration: &configuration::Configuration, app_id: &str, outcome_names: &str, outcome_names2: Option<&str>, outcome_time_range: Option<&str>, outcome_platforms: Option<&str>, outcome_attribution: Option<&str>) -> Result<crate::models::OutcomesData, Error<GetOutcomesError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/outcomes", configuration.base_path, app_id=crate::apis::urlencode(app_id));
    let mut req_builder = client.request(reqwest::Method::GET, uri_str.as_str());

    req_builder = req_builder.query(&[("outcome_names", &outcome_names.to_string())]);
    if let Some(ref str) = outcome_names2 {
        req_builder = req_builder.query(&[("outcome_names[]", &str.to_string())]);
    }
    if let Some(ref str) = outcome_time_range {
        req_builder = req_builder.query(&[("outcome_time_range", &str.to_string())]);
    }
    if let Some(ref str) = outcome_platforms {
        req_builder = req_builder.query(&[("outcome_platforms", &str.to_string())]);
    }
    if let Some(ref str) = outcome_attribution {
        req_builder = req_builder.query(&[("outcome_attribution", &str.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<GetOutcomesError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Returns an array of segments from an app.
pub async fn get_segments(configuration: &configuration::Configuration, app_id: &str, offset: Option<i32>, limit: Option<i32>) -> Result<crate::models::GetSegmentsSuccessResponse, Error<GetSegmentsError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/segments", configuration.base_path, app_id=crate::apis::urlencode(app_id));
    let mut req_builder = client.request(reqwest::Method::GET, uri_str.as_str());

    if let Some(ref str) = offset {
        req_builder = req_builder.query(&[("offset", &str.to_string())]);
    }
    if let Some(ref str) = limit {
        req_builder = req_builder.query(&[("limit", &str.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<GetSegmentsError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Returns the Users properties, Aliases, and Subscriptions.
pub async fn get_user(configuration: &configuration::Configuration, app_id: &str, alias_label: &str, alias_id: &str) -> Result<crate::models::User, Error<GetUserError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/users/by/{alias_label}/{alias_id}", configuration.base_path, app_id=crate::apis::urlencode(app_id), alias_label=crate::apis::urlencode(alias_label), alias_id=crate::apis::urlencode(alias_id));
    let mut req_builder = client.request(reqwest::Method::GET, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<GetUserError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Transfers this Subscription to the User identified by the identity in the payload.
pub async fn transfer_subscription(configuration: &configuration::Configuration, app_id: &str, subscription_id: &str, transfer_subscription_request_body: crate::models::TransferSubscriptionRequestBody) -> Result<crate::models::UserIdentityBody, Error<TransferSubscriptionError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/subscriptions/{subscription_id}/owner", configuration.base_path, app_id=crate::apis::urlencode(app_id), subscription_id=crate::apis::urlencode(subscription_id));
    let mut req_builder = client.request(reqwest::Method::PATCH, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }
    req_builder = req_builder.json(&transfer_subscription_request_body);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<TransferSubscriptionError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Unsubscribe an email with a token when using your own custom email unsubscribe landing page
pub async fn unsubscribe_email_with_token(configuration: &configuration::Configuration, app_id: &str, notification_id: &str, token: &str) -> Result<crate::models::GenericSuccessBoolResponse, Error<UnsubscribeEmailWithTokenError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/notifications/{notification_id}/unsubscribe", configuration.base_path, app_id=crate::apis::urlencode(app_id), notification_id=crate::apis::urlencode(notification_id));
    let mut req_builder = client.request(reqwest::Method::POST, uri_str.as_str());

    req_builder = req_builder.query(&[("token", &token.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<UnsubscribeEmailWithTokenError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Updates the name or configuration settings of an existing OneSignal app
pub async fn update_app(configuration: &configuration::Configuration, app_id: &str, app: crate::models::App) -> Result<crate::models::App, Error<UpdateAppError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}", configuration.base_path, app_id=crate::apis::urlencode(app_id));
    let mut req_builder = client.request(reqwest::Method::PUT, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.organization_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }
    req_builder = req_builder.json(&app);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<UpdateAppError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Updates a specified live activity.
pub async fn update_live_activity(configuration: &configuration::Configuration, app_id: &str, activity_id: &str, update_live_activity_request: crate::models::UpdateLiveActivityRequest) -> Result<crate::models::UpdateLiveActivitySuccessResponse, Error<UpdateLiveActivityError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/live_activities/{activity_id}/notifications", configuration.base_path, app_id=crate::apis::urlencode(app_id), activity_id=crate::apis::urlencode(activity_id));
    let mut req_builder = client.request(reqwest::Method::POST, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }
    req_builder = req_builder.json(&update_live_activity_request);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<UpdateLiveActivityError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Updates an existing Subscriptions properties.
pub async fn update_subscription(configuration: &configuration::Configuration, app_id: &str, subscription_id: &str, subscription_body: crate::models::SubscriptionBody) -> Result<(), Error<UpdateSubscriptionError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/subscriptions/{subscription_id}", configuration.base_path, app_id=crate::apis::urlencode(app_id), subscription_id=crate::apis::urlencode(subscription_id));
    let mut req_builder = client.request(reqwest::Method::PATCH, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }
    req_builder = req_builder.json(&subscription_body);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let entity: Option<UpdateSubscriptionError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

/// Updates an existing Users properties.
pub async fn update_user(configuration: &configuration::Configuration, app_id: &str, alias_label: &str, alias_id: &str, update_user_request: crate::models::UpdateUserRequest) -> Result<crate::models::PropertiesBody, Error<UpdateUserError>> {
    let configuration = configuration;

    let client = &configuration.client;

    let uri_str = format!("{}/apps/{app_id}/users/by/{alias_label}/{alias_id}", configuration.base_path, app_id=crate::apis::urlencode(app_id), alias_label=crate::apis::urlencode(alias_label), alias_id=crate::apis::urlencode(alias_id));
    let mut req_builder = client.request(reqwest::Method::PATCH, uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Adds a telemetry header
    req_builder = req_builder.header("OS-Usage-Data", "kind=sdk, sdk-name=onesignal-rust, version=5.2.0-beta1");

    if let Some(ref token) = configuration.rest_api_key_token {
        req_builder = req_builder.header("Authorization", format!("Key {}", token.to_owned()));
    }
    req_builder = req_builder.json(&update_user_request);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if !status.is_client_error() && !status.is_server_error() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<UpdateUserError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status: status, content: content, entity: entity };
        Err(Error::ResponseError(error))
    }
}

