/*
 * OneSignal
 *
 * A powerful way to send personalized messages at scale and build effective customer engagement strategies. Learn more at onesignal.com
 *
 * The version of the OpenAPI document: 5.3.0
 * Contact: devrel@onesignal.com
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct StartLiveActivityRequest {
    /// An internal name to assist with your campaign organization. This does not get displayed in the message itself.
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "event")]
    pub event: EventType,
    /// Set a unique activity_id to track and manage the Live Activity.
    #[serde(rename = "activity_id")]
    pub activity_id: String,
    /// Default/static data to initialize the Live Activity upon start.
    #[serde(rename = "event_attributes")]
    pub event_attributes: serde_json::Value,
    /// Dynamic content used to update the running Live Activity at start. Must match the ContentState interface defined in your app.
    #[serde(rename = "event_updates")]
    pub event_updates: serde_json::Value,
    #[serde(rename = "contents")]
    pub contents: Box<crate::models::LanguageStringMap>,
    #[serde(rename = "headings")]
    pub headings: Box<crate::models::LanguageStringMap>,
    /// Accepts Unix timestamp in seconds. When time reaches the configured stale date, the system considers the Live Activity out of date, and the ActivityState of the Live Activity changes to ActivityState.stale.
    #[serde(rename = "stale_date", skip_serializing_if = "Option::is_none")]
    pub stale_date: Option<i32>,
    /// Delivery priority through the push provider (APNs). Pass 10 for higher priority notifications, or 5 for lower priority notifications. Lower priority notifications are sent based on the power considerations of the end user's device. If not set, defaults to 10.
    #[serde(rename = "priority", skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    /// iOS 15+. A score to indicate how a notification should be displayed when grouped. Use a float between 0-1.
    #[serde(rename = "ios_relevance_score", skip_serializing_if = "Option::is_none")]
    pub ios_relevance_score: Option<f32>,
    /// Correlation and idempotency key. A request received with this parameter will first look for another notification with the same idempotency key. If one exists, a notification will not be sent, and result of the previous operation will instead be returned. Therefore, if you plan on using this feature, it's important to use a good source of randomness to generate the UUID passed here. This key is only idempotent for 30 days. After 30 days, the notification could be removed from our system and a notification with the same idempotency key will be sent again.   See Idempotent Notification Requests for more details writeOnly: true 
    #[serde(rename = "idempotency_key", skip_serializing_if = "Option::is_none")]
    pub idempotency_key: Option<String>,
    /// Target specific users by aliases assigned via API. An alias can be an external_id, onesignal_id, or a custom alias. Accepts an object where keys are alias labels and values are arrays of alias IDs to include Example usage: { \"external_id\": [\"exId1\", \"extId2\"], \"internal_label\": [\"id1\", \"id2\"] } Not compatible with any other targeting parameters. REQUIRED: REST API Key Authentication Limit of 2,000 entries per REST API call Note: If targeting push, email, or sms subscribers with same ids, use with target_channel to indicate you are sending a push or email or sms.
    #[serde(rename = "include_aliases", skip_serializing_if = "Option::is_none")]
    pub include_aliases: Option<::std::collections::HashMap<String, Vec<String>>>,
    /// Specific subscription ids to target. Not compatible with other targeting parameters.
    #[serde(rename = "include_subscription_ids", skip_serializing_if = "Option::is_none")]
    pub include_subscription_ids: Option<Vec<String>>,
    /// Segment names to include. Only compatible with excluded_segments.
    #[serde(rename = "included_segments", skip_serializing_if = "Option::is_none")]
    pub included_segments: Option<Vec<String>>,
    /// Segment names to exclude. Only compatible with included_segments.
    #[serde(rename = "excluded_segments", skip_serializing_if = "Option::is_none")]
    pub excluded_segments: Option<Vec<String>>,
    #[serde(rename = "filters", skip_serializing_if = "Option::is_none")]
    pub filters: Option<Vec<crate::models::FilterExpression>>,
}

impl StartLiveActivityRequest {
    pub fn new(name: String, event: EventType, activity_id: String, event_attributes: serde_json::Value, event_updates: serde_json::Value, contents: crate::models::LanguageStringMap, headings: crate::models::LanguageStringMap) -> StartLiveActivityRequest {
        StartLiveActivityRequest {
            name,
            event,
            activity_id,
            event_attributes,
            event_updates,
            contents: Box::new(contents),
            headings: Box::new(headings),
            stale_date: None,
            priority: None,
            ios_relevance_score: None,
            idempotency_key: None,
            include_aliases: None,
            include_subscription_ids: None,
            included_segments: None,
            excluded_segments: None,
            filters: None,
        }
    }
}

/// 
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum EventType {
    #[serde(rename = "start")]
    Start,
}

impl Default for EventType {
    fn default() -> EventType {
        Self::Start
    }
}

